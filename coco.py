#coding: utf-8
import argparse

from os import makedirs

from os.path import join, exists, dirname, basename, splitext, abspath

import spacy

import json

import HTML

from pycocotools.coco import COCO

from urllib.parse import quote

import settings

from utils import progressbar, sample_unrelated_inplace

from tags import NounTags, CompoundTags, SyntacticMergedTags


def coco_tags(extractor):
    """ estimates tags from COCO captions

    Args:
       extractor (obj): Tag estimator

    Return:
       dict with all the info (see impl.)
    """

    res = {}
    for set_ in ('train2014', 'val2014',):
        res[set_] = {}

        coco_instances = COCO(join(settings.COCO_PATH,
                                   'annotations/instances_{}.json'.format(set_)))

        coco_captions = COCO(join(settings.COCO_PATH,
                                  'annotations/captions_{}.json'.format(set_)))

        print('generating tags for \'{}\' ...'.format(set_))
        for im in progressbar(coco_instances.getImgIds()):
            # load captions
            cpt_anns = coco_captions.loadAnns(coco_captions.getAnnIds(imgIds=im))
            cpt = [a['caption'] for a in cpt_anns]

            # load categories
            inst_anns = coco_instances.loadAnns(coco_instances.getAnnIds(imgIds=im))
            cat_ids = list(set([a['category_id'] for a in inst_anns]))
            cat = sorted([coco_instances.cats[i]['name'] for i in cat_ids])

            # tags and frequency counts
            tags, scores = extractor.process(cpt)

            res[set_][im] = {
                'file_name': coco_instances.imgs[im]['file_name'],
                'category_ids': cat_ids,
                'category_names': cat,
                'captions': cpt,
                'tags': tags,
                'scores': scores,
            }
        print('done')

    all_tags = []
    for imdata in res['train2014'].values():
        all_tags += [w for w in imdata['tags']]
    for imdata in res['val2014'].values():
        all_tags += [w for w in imdata['tags']]
    all_tags = list(set(all_tags))
    res['tags'] = all_tags

    return res


def htmlize(res, set_, output_file, n_samples=100):
    """ writes an HTML file for visualization

    Args:
       res (dict): results generated by coco_tags
       set_ (str): COCO set
       output_file (str): destination file
       n_samples (int): visualize first `n_samples` samples
    """
    data = res[set_]

    tbl = HTML.Table(header_row=['image', 'category_names', 'captions', 'tags'])
    def html_img(text, url):
        if len(text) > 48:
            text = text[:20] + '...' + text[-24:]
        return '<center>{}</center><img src={} width=320>'.format(text, url)

    for im in sorted(data.keys())[:n_samples]:
        html_category_names = '<br>'.join(data[im]['category_names'])
        html_captions = '<br>'.join(data[im]['captions'])

        # tag-score pairs
        tags = data[im]['tags']
        scores = data[im]['scores']
        ts = [(tags[i], scores[i]) for i in range(len(tags))]
        html_tags = '<br>'.join(['{:20s}: {:.3f}'.format(t, s) for t, s in ts])

        fname = join(abspath(settings.COCO_PATH), set_, data[im]['file_name'])
        tbl.rows.append([html_img(basename(fname), fname),
                         html_category_names,
                         html_captions,
                         html_tags])

    htmlcode = str(tbl)
    f = open(output_file, 'w')
    f.write(htmlcode)
    f.write('<p>')
    f.close()
    print('{} saved'.format(output_file))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='COCO tags from captions',
        add_help=True,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.register('type', 'bool', lambda s: s.lower() in ("yes", "true", "t", "1", "on"))
    parser.add_argument('--html', help='generate HTML visualization of first 100 entries', action='store_true')
    parser.add_argument('--mode', help='noun / compound', type=str, default='noun')
    parser.add_argument('--unrelated', help='sample unrelated tags', action='store_true')
    parser.add_argument('--syntactic', help='enable syntactic mode', action='store_true')
    parser.add_argument('--merged', help='enable merged mode', action='store_true')
    parser.add_argument('--alpha', help='alpha', type=float, default=0.99)
    parser.add_argument('--min_count', help='min word count', type=int, default=0)
    parser.add_argument('--output', help='output file (JSON)', type=str, default='./coco_tags.json')
    args = parser.parse_args()

    nlp = spacy.load(settings.SPACY_MODEL)
    if args.mode == 'noun':
        extractor = NounTags(nlp, alpha=args.alpha, min_count=args.min_count, syntactic=args.syntactic)
    elif args.mode == 'compound':
        extractor = CompoundTags(nlp, alpha=args.alpha, min_count=args.min_count, syntactic=args.syntactic)
    else:
        raise RuntimeError('not a valid mode')

    if args.merged:
        extractor = SyntacticMergedTags(extractor, hyperonymcheck=True)

    # compute tags from captions
    if not exists(args.output):
        res = coco_tags(extractor)

        if args.unrelated:
            sample_unrelated_inplace(res, settings.N_UNRELATED)

        if not exists(dirname(args.output)):
            makedirs(dirname(args.output))
        json.dump(res, open(args.output, 'w'))
        print('{} saved'.format(args.output))
    else:
        print('{} already exist'.format(args.output))

    # generate HTML
    if args.html:
        data = json.load(open(args.output, 'r'))
        htmlfile = splitext(args.output)[0] + '.html'
        htmlize(data, 'train2014', htmlfile)
